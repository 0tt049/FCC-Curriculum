#+title: Object Oriented JavaScript

* OOP, or Object Oriented Programming, is one of the major approaches to the software development process. In OOP, objects and classes organize code to describe things and what they can do.

In this course, you'll learn the basic principles of OOP in JavaScript, including the this keyword, prototype chains, constructors, and inheritance.

** TODO [Create a Basic JavaScript Object](./basic_object.js)
** TODO [Use Dot Notation to Access the Properties of an Object](./dotnot_to_acces.js)
** TODO [Create a Method on an Object](./create_method_on_object.js)
** TODO [Make Code More Reusable with the this Keyword](./more_reusable.js)
** TODO [Define a Constructor Function](./constructor_function.js)

** Use a Constructor to Create Objects
*** INFO

Here's the Bird constructor from the previous challenge:

#+begin_SRC javascript options

function Bird() {
  this.name = "Albert";
  this.color  = "blue";
  this.numLegs = 2;
}

let blueBird = new Bird();

#+end_SRC


NOTE: this inside the constructor always refers to the object being created.

Notice that the new operator is being used when calling a constructor. This tells JavaScript to create a new instance of Bird called blueBird. Without the new operator, this inside the constructor would not point to the newly created object, giving unexpected results. Now blueBird has all the properties defined inside the Bird constructor:


#+begin_SRC javascript

blueBird.name;
blueBird.color;
blueBird.numLegs;

#+end_SRC

Just like any other object, its properties can be accessed and modified:

#+begin_SRC javascript

blueBird.name = 'Elvira';
blueBird.name;

#+end_SRC

*** CODE:

Use the Dog constructor from the last lesson to create a new instance of Dog, assigning it to a variable hound.

#+begin_src javascript

function Dog() {
  this.name = "Rupert";
  this.color = "brown";
  this.numLegs = 4;
}
// Only change code below this line

let hound = new Dog();

#+end_src

** Extend Constructors to Receive Arguments
*** INFO:

The Bird and Dog constructors from the last challenge worked well. However, notice that all Birds that are created with the Bird constructor are automatically named Albert, are blue in color, and have two legs. What if you want birds with different values for name and color? It's possible to change the properties of each bird manually but that would be a lot of work:

#+begin_src javascript

let swan = new Bird();
swan.name = "Carlos";
swan.color = "white";

#+end_src

Suppose you were writing a program to keep track of hundreds or even thousands of different birds in an aviary. It would take a lot of time to create all the birds, then change the properties to different values for every one. To more easily create different Bird objects, you can design your Bird constructor to accept parameters:

#+begin_src javascript

function Bird(name, color) {
  this.name = name;
  this.color = color;
  this.numLegs = 2;
}

#+end_src

Then pass in the values as arguments to define each unique bird into the Bird constructor: let cardinal = new Bird("Bruce", "red"); This gives a new instance of Bird with name and color properties set to Bruce and red, respectively. The numLegs property is still set to 2. The cardinal has these properties:

#+begin_src javascript

cardinal.name
cardinal.color
cardinal.numLegs

#+end_src

The constructor is more flexible. It's now possible to define the properties for each Bird at the time it is created, which is one way that JavaScript constructors are so useful. They group objects together based on shared characteristics and behavior and define a blueprint that automates their creation.

*** CODE:

Create another Dog constructor. This time, set it up to take the parameters name and color, and have the property numLegs fixed at 4. Then create a new Dog saved in a variable terrier. Pass it two strings as arguments for the name and color properties.

#+begin_src javascript

function Dog(name, color) {
    this.name = name;
    this.color = color;
    this.numLegs = 4;
}

let terrier = new Dog("Max", "grey");

#+end_src

** Verify an Object's Constructor with instanceof
*** INFO:

Anytime a constructor function creates a new object, that object is said to be an instance of its constructor. JavaScript gives a convenient way to verify this with the ~instanceof~ operator. ~instanceof~ allows you to compare an object to a constructor, returning ~true~ or ~false~ based on whether or not that object was created with the constructor. Here's an example:

 #+begin_src javascript

let Bird = function(name, color) {
  this.name = name;
  this.color = color;
  this.numLegs = 2;
}

let crow = new Bird("Alexis", "black");

crow instanceof Bird;

#+end_src


This ~instanceof~ method would return true.

If an object is created without using a constructor, ~instanceof~ will verify that it is not an instance of that constructor:

#+begin_src javascript

let canary = {
  name: "Mildred",
  color: "Yellow",
 numLegs: 2
};

canary instanceof Bird;

#+end_src

This ~instanceof~ method would return false.

*** CODE:

Create a new instance of the House constructor, calling it ~myHouse~ and passing a number of bedrooms. Then, use ~instanceof~ to verify that it is an instance of House.

#+begin_src javascript

function House(numBedrooms) {
  this.numBedrooms = numBedrooms;
}

// Only change code below this line

let myHouse = new House(3);

myHouse instanceof House;

#+end_src

** Understand Own Properties
** Use Prototype Properties to Reduce Duplicate Code
** [Iterate Over All Properties]
** [Understand the Constructor Property]
** [Change the Prototype to a New Object]
** [Remember to Set the Constructor Property when Changing the Prototype]
** [Understand Where an Objectâ€™s Prototype Comes From]
** [Understand the Prototype Chain]
** [Use Inheritance So You Don't Repeat Yourself]
** [Inherit Behaviors from a Supertype]
** [Set the Child's Prototype to an Instance of the Parent]
** [Reset an Inherited Constructor Property]
** [Add Methods After Inheritance]
** [Override Inherited Meth
** [Use a Mixin to Add Common Behavior Between Unrelated Objects]
** [Use Closure to Protect Properties Within an Object from Being Modified Externally]
** [Understand the Immediately Invoked Function Expression (IIFE)]
** [Use an IIFE to Create a Module]
